understand HTTP in details
create MY OWN simple webserver



A more full-featured HTTP server would look at several other HTTP headers. It would look
at the Host header to determine which site it is hosting. Our server only supports hosting
one site, so this header is not meaningful for us.

A production server would also look at headers such as Accept-Encoding and Accept-
Language, which could inform a proper response format. Our server just ignores these, and
it instead serves files in only the most straightforward way.
An HTTP server is a complicated program. It must handle multiple simultaneous
connections, parse a complex text-based protocol, handle malformed requests with the
proper errors, and serve files. The example we develop in this chapter is greatly simplified
from a production-ready server, but it is still a few hundred lines of code. We benefit from
breaking the program down into separate functions and data structures.
At the global level, our program stores a linked list of data structures. This linked list
contains one separate data structure for each connected client. This data structure stores
information about each client such as their address, their socket, and their data received so
far. We implement many helper functions that work on this global linked list. These
functions are used to add new clients, drop clients, wait on client data, look up clients by
their socket (as sockets are returned by select()), serve files to clients, and send error
messages to clients.
Our server's main loop can then be simplified. It waits for new connections or new data.
When new data is received, it checks whether the data consists of a complete HTTP request.
If a complete HTTP request is received, the server attempts to send the requested resource.
If the HTTP request is malformed or the resource cannot be found, then the server sends an
error message to the connected client instead.

Note that send() may block on large files. In a truly robust, production-ready server, you
would need to handle this case. It could be done by using select() to determine when
each socket is ready to read. Another common method is to use fork() or similar APIs to
create separate threads/processes for each connected client. For simplicity, our server
accepts the limitation that send() blocks on large files. Please refer to Chapter 13, Socket
Programming Tips and Pitfalls, for more information about the blocking behavior of send().
read the 6th chapter of the book
build a functional web client


-- othman
-> path begin
-> allowd_methos {server_block}
-> format request valid

